## 44 | 工厂模式（上）：我为什么说没事不要随便用工厂模式创建对象？
### 一、简单工厂(Simple Factory)
0、示例：一个生产接口有个createCar方法，创建一个简单工厂根据入参生产奔驰、宝马、路虎等车。  
1、第一种实现方式：通过一组if分支判断逻辑生成不同的对象。  
2、第二种实现方式：事先将对象创建好缓存起来，使用时再从缓存中获取对象。  
3、在简单工厂模式的代码实现中，有多处if分支判断逻辑，违背开闭原则，但权衡扩展性和可读性，这样的代码是没问题的。  
4、应用多态或设计模式来替代if分支判断逻辑，虽然提高了代码的扩展性，更加符合开闭原则，但增加了类的个数，牺牲了代码的可读性。

### 二、工厂方法(Factory Method)
0、示例：一个生产接口有个createCar方法，创建一个简单工厂根据入参生产奔驰工厂、宝马工厂、路虎工厂等工厂，由对应的工厂生成具体的车。    
1、工厂方法模式比简单工厂模式更加符合开闭原则。使用时可以用简单工厂类去创建其他工厂。  
2、什么时候该用工厂方法模式，而非简单工厂模式呢？  
(1)如果代码逻辑本身不复杂，就没必要使用工厂方法，否则可以使用工厂方法模式。  
(2)在某些场景下，如果对象不可复用，并且想避免if-else分支逻辑，此时推荐使用工厂方法模式。

### 三、抽象工厂(Abstract Factory)
0、示例：一个生产接口有个createCar、createAirCraft等多个方法，创建一个简单工厂根据入参生产奔驰工厂、宝马工厂、路虎工厂等工厂，由对应的工厂生成具体的车或飞机(假设车工厂能生产飞机)。   
1、抽象工厂模式的应用场景比较特殊，没有简单工厂和工厂方法常用。

### 四、判断要不要使用工厂模式最本质的参考标准
1、封装变化：创建逻辑可能变化，封装成工厂类之后，创建逻辑的变更对调用者透明。  
2、代码复用：创建代码抽离到独立的工厂类之后可以复用。  
3、隔离复杂性：封装复杂的创建逻辑，调用者无需了解如何创建对象。  
4、控制复杂度：将创建代码抽象出来，让原本的函数或类职责更单一，代码更简洁。  

