## 41 | 单例模式（上）：为什么说支持懒加载的双重检测不比饿汉式更优？
### 一、为什么要使用单例？
1、一个类只允许创建一个对象(或者实例)，那这个类就是一个单例类，这种设计模式就叫做单例模式。  
2、实战案例一：处理资源访问冲突.  
(1)定义一个logger类，UserController和OrderController同时往这个类中写日志。由于是在两个类中创建两个logger类，因此会存在日志相互覆盖的问题。  
(2)如何解决这种问题：
* 对象锁：由于不用对象之间并不共享同一把锁，通过不同对象调用时，锁并不生效。
* 类锁、分布式锁、并发队列、单例：可以解决。

3、实战案例二：表示全局唯一类.  
(1)如果有些数据在系统中只应保存一份，那就比较适合设计为单例类。例如配置信息类、唯一递增ID号码生成器等。

### 二、如何实现一个单例？
1、实现一个单例，需要关注的几个点：  
(1)构造函数需要是private访问权限的，避免外部通过new创建实例。  
(2)考虑对象创建时线程安全的问题。  
(3)考虑是否支持延迟加载。  
(4)考虑getInstance()性能是否高(是否加锁)。  
2、饿汉式  
(1)在类加载时，instance静态实例已经创建并初始化好了。  
(2)instance实例的创建过程是线程安全的，不支持延迟加载。  
3、懒汉式  
(1)支持延迟加载，但由于加锁导致函数的并发度低，效率低。  
4、双重检测  
(1)既支持延迟加载、又支持高并发。  
(2)需要给instance加上volatile关键字，防止instance未完全初始化就被其他线程访问到。  
5、静态内部类  
(1)既支持延迟加载，又能保证线程安全。  
(2)当外部类加载时，并不会创建静态内部类，只有当调用getInstance时，内部类才会被加载。instance的唯一性、创建过程的线程安全性，都由JVM来保证。  
6、枚举  
(1)通过java枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性。  
(2)处理枚举实现的单例模式，其他几种都可以利用反射构造新的对象，从而破坏单例模式。  

